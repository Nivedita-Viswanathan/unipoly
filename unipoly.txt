invo:=function(G)
# returns an involution produced from a random element in the group G.
# We assume that the distribution of the elements of even order in the group G
# is pretty high, which is the case for Lie type groups of odd characteristic.

local seek, g;

seek:=false;
	while not seek do
		g:=PseudoRandom(G);
			if Order(g) mod 2 = 0 then
				return g^(Order(g)/2);
			else
				seek:=false;
			fi;
	od;
end;
################################################################################
################################################################################
################################################################################
is4div:=function(g,id,Eo)
# Here, "g" belongs to a group with an exponent "E" and "Eo" is the odd part
# of the exponent "E", and "id" is the identity of the group.
# This function returns the truth value whether the order of "g" is divisible by 4.

g:=g^Eo;
	if g=id or g^2= id then
		return false;
	else
		return true;
	fi;
end;
################################################################################
################################################################################
################################################################################
ds:=function(G)

# returns some generators for the derived subgroup of G.

local i,j,z,g,h,l;

l:=[];
i:=1;
   while i <= 20 do
    z:=Identity(G);
       for j in [1..10] do
        g:=PseudoRandom(G);
        h:=PseudoRandom(G);
        z:=g^(-1)*h^(-1)*g*h*z;
       od;
    l[i]:=z;
    i:=i+1;
   od;
return l;
end;
################################################################################
################################################################################
################################################################################
cent:=function(t,G)
# Here, "G" is a group and "t" is an involution in "G".
# This function returns some generators of the centralizer
# of "t" in "G", "C_G(t)", by using only the map "zeta_1".

local l,seek,i,j,x,y,o;

l:=[];
	for i in [1..40] do
		seek:=false;
			while not seek do
				x:=PseudoRandom(G);
				y:=t*t^x;
				o:=Order(y);
					if o mod 2 = 1 then
						l[i]:=(y^((o+1)/2))*x^(-1);
						seek:=true;
					else
						seek:=false;
					fi;
			od;
	od;
return l;
end;
################################################################################
################################################################################
################################################################################
permij:=function(s,i,j)
# Here, "s" is a list of generators of a group "PSL(2,q)" or "PGL(2,q)", "q" odd.
# "i" and "j" are commuting conjugate involutions.
# This function returns an element of order 3 in the normaliser of i,j,i*j.
# The output conjugates in the following way: i--> i*j --> j --> i.

local x,g1,g2,g3,g,h1,h2,h3,o1,finished,t1,y1,f1,o2,z1,u1;

x:=Group(s);
g1:=i;
g2:=j;
g3:=i*j;
finished:=false;
	while not finished do
		g:=PseudoRandom(x);
		h1:=g1^g;
		h2:=g2^g;
		h3:=g3^g;
		o1:=Order(g1*h2);
			if o1 mod 2 = 0 then
				finished:=false;
			else
				t1:=g1*h2;
				y1:=t1^((o1+1)/2);
				f1:=g3^(g*(y1^-1));
				o2:=Order(g2*f1);
					if o2 mod 2 = 0 then
						finished:=false;
					else
						finished:=true;
						z1:=g2*f1;
						u1:=z1^((o2+1)/2);
					fi;
			fi;
	od;
return (g*(y1^-1)*(u1^-1));
end;
################################################################################
################################################################################
################################################################################
unipotency:=function(s,i,j)
# Here, "s" is a list of generators of the group PGL(2,q)=SO(3,q) or PSL(2,q)
# "q" odd, and "i" and "j" are involutions.
# This function returns the truth value whether the product "i*j" is a
# unipotent element or not.

local id,u,x,ci,found,ti;

id:=i^2;
u:=i*j;
x:=Group(s);
ci:=Group(cent(i,x));
found:=false;
	while not found do
		ti:=PseudoRandom(ci);
			if (ti<>id) and (ti^2<>id) and (ti^3<>id) then
				found:=true;
			fi;
	od;
	if (u<>u^ti) and ((u*(u^ti)*(u^-1))*((u^ti)^-1)=id) and (u<>id) and (u^2<>id) then
		return true;
	else
		return false;
	fi;
end;
################################################################################
################################################################################
################################################################################
reif:=function(s,i,j)
# Here, "s" is a list of generators for PGL(2,q)=SO(3,q), q odd.
# "i" and "j" are commuting involutions.
# If there exists an involution commuting with "i" and "j", it returns [false,g], where
# "g" is the desired involution commuting with both "i" and "j".
# Otherwise, the product "i*j" is unipotent and it returns the list [true, i,j,i*j].

local x,o,z,r,vi,ci,l,count,g,R,T,r1,r2,r3,t1,t2,t3,g2,h2,o2,z2,ll,dill,found,oo,k;

#########
# We first check for unipotency. If fails, then we start the procedure to
# construct desired involution.
#########
	if unipotency(s,i,j) then
		return [true,i,j,i*j];
	else
		x:=Group(s);
		o:=Order(i*j);
			if o mod 2 = 0 then
				return [false,(i*j)^(o/2)];
			else
				r:=i*j;
				vi:=cent(i,x);
				ci:=Group(vi);
				l:=[];
				count:=1;
					while count <= 20 do
						g:=PseudoRandom(ci);
							if Order(g) >= 4 then
								l[count]:=g;
								count:=count+1;
							fi;
					od;
				R:=Group(r);
				T:=Group(l);
				ll:=[];
########
# For the construction of the centralizer of the desired involution, we use
# the word ”w1*z1*w2*z2*w3*z3” where z1, z2, z3 are elements from the group
# R and w1, w2, w3 are elements from the group T.
########
					for k in [1..50] do
						r1:=PseudoRandom(R);
						r2:=PseudoRandom(R);
						r3:=PseudoRandom(R);
						t1:=PseudoRandom(T);
						t2:=PseudoRandom(T);
						t3:=PseudoRandom(T);
						g2:=r1*t1*r2*t2*r3*t3;
						h2:=(r1*(t1^-1)*r2*(t2^-1)*r3*(t3^-1))*((t3^-1)*(r3^-1)*(t2^-1)*(r2^-1)*(t1^-1)*(r1^-1));
						o2:=Order(h2);
							if o2 mod 2 = 0 then
								z2:=h2^(o2/2);
							else
								z2:=(h2^((o2+1)/2))*g2;
							fi;
						ll[k]:=z2;
					od;
				dill:=Group(ll);
#######
# Now, we try to locate the central involution in the centre of the centralizer
# of the desired involution.
#######
				found:=false;
					while not found do
						g:=PseudoRandom(dill);
						oo:=Order(g);
							if (oo mod 2 = 0) and (oo>=4) then
								g:=g^(oo/2);
									if (g*i=i*g) and (g*j=j*g) then
										return [false,g];
									fi;
							fi;
					od;
			fi;
	fi;
end;
################################################################################
################################################################################
################################################################################
inter:=function(s,i1,i2,j1,j2)
# Here, "s" is a list of generators for PGL(2,q), q odd.
# The function constructs the intersection of the lines passing thru "i1,i2" and "j1,j2".
# It returns either
# [false, P] where "P" is an involution corresponding to the intersection; or
# [true, P1,P2,P3] where "P1,P2" are involutions and "P3=P1*P2" is a unipotent element.

local z1,z2;

z1:=reif(s,i1,i2);
if z1[1]=true then
   return z1;
fi;
z2:=reif(s,j1,j2);
if z2[1]=true then
   return z2;
fi;
return reif(s,z1[2],z2[2]);
end;
################################################################################
################################################################################
################################################################################
unity:=function(s,i1,j1,k1,ti1,sc)
# Here, "s" is a list of generators for PGL(2,q), q odd.
# "i1,j1,k1" are involutions determining a basis triangle for the projective geometry.
# "ti1" is an element of order 4 in C_G(i) whose square is "i1"
# "sc" is an element of order 3 permuting "i1,j1,k1".
# This function returns either
# [false, P1,P2,P3] where "P1,P2,P3" are unit elements on the lines "j1vk1",
# "i1vk1" and "i1vj1" respectively; or
# [true, P1,P2,P3] where "P1,P2" are involutions with "P3=P1*P2" is a unipotent element.

local N,lli,llj,llk,i,j,k,g,found,gi,gj,gk,x1,y1,id,tj1;

id:=ti1^4;
N:=[id, ti1, ti1^2, ti1^3, j1, ti1*j1, (ti1^2)*j1, (ti1^3)*j1, sc, ti1*sc, (ti1^2)*sc, (ti1^3)*sc, j1*sc, ti1*j1*sc, (ti1^2)*j1*sc, (ti1^3)*j1*sc,   sc^2,  ti1*sc^2, (ti1^2)*sc^2, (ti1^3)*sc^2, j1*sc^2, ti1*j1*sc^2, (ti1^2)*j1*sc^2,(ti1^3)*j1*sc^2 ];
lli:=[];
llj:=[];
llk:=[];
i:=1;
j:=1;
k:=1;
	for g in N do
		if (Order(g)=2) and (j1^g=k1) then
			lli[i]:=g;
			i:=i+1;
		fi;
	od;
	for g in N do
		if (Order(g)=2) and (i1^g=k1) then
			llj[j]:=g;
			j:=j+1;
		fi;
	od;
	for g in N do
		if (Order(g)=2) and (i1^g=j1) then
			llk[k]:=g;
			k:=k+1;
		fi;
	od;
found:=false;
	for gi in lli do
		for gj in llj do
			for gk in llk do
				if gk^gj=gi and gi^sc=gj and gi^(sc^2)=gk then
					return [gi,gj,gk];
				fi;
			od;
		od;
	od;
end;
################################################################################
################################################################################
################################################################################
add:=function(s,mid,i1,j1,k1,a,b)
# Here, "s" is a list of generators for PGL(2,q), q odd.
# "i1,j1,k1" are involutions determining a basis triangle for the projective geometry.
# "mid" is the point corresponding to [1,1,1] in the triangle "i1,j1,k1".
# "a" and "b" are two points on the axis "j1 v k1". Here, "j1=0", "k1=\infty".
# This function computes "a+b" on the axis "j1 v k1".
# It returns either
# [false, P] where "P" is an involution corresponding to "a+b"; or
# [true, P1,P2,P3] where "P1,P2" are involutions with "P3=P1*P2" is a unipotent element.


local aprime,bprime,ab,se;

aprime:=inter(s,i1,a,mid,k1);
	if aprime[1]=true then
		return aprime;
	fi;
se:=inter(s,mid,k1,i1,j1);
	if se[1]=true then
		return se;
	fi;
bprime:=inter(s,i1,k1,b,se[2]);
	if bprime[1]=true then
		return bprime;
	fi;
ab:=inter(s,j1,k1,aprime[2],bprime[2]);
	if ab[1]=true then
		return ab;
	else
		return ab;
	fi;
end;
################################################################################
################################################################################
################################################################################
mult:=function(s,mid,i1,j1,k1,a,b)
# Here, "s" is a list of generators for PGL(2,q), q odd.
# "i1,j1,k1" are involutions determining a basis triangle for the projective geometry.
# "mid" is the point corresponding to [1,1,1] in the triangle "i1,j1,k1".
# "a" and "b" are two points on the axis "j1 v k1". Here, "j1=0", "k1=\infty".
# This function computes "a \times b" on the axis "j1 v k1".
# It returns either
# [false, P] where "P" is an involution corresponding to "a\times b"; or
# [true, P1,P2,P3] where "P1,P2" are involutions with "P3=P1*P2" is a unipotent element.


local aprime,bprime,ab;

aprime:=inter(s,i1,a,j1,mid);
	if aprime[1]=true then
		return aprime;
	fi;
bprime:=inter(s,b,mid,i1,k1);
	if bprime[1]=true then
		return bprime;
	fi;
ab:=inter(s,aprime[2],bprime[2],j1,k1);
return ab;
end;
################################################################################
################################################################################
################################################################################
log2:=function(n)
# returns a list consisting of natural numbers with which 2-powers add up to "n".

local stop,i,l,finished,j,k,a;

l:=[];
stop:=false;
finished:=false;
i:=0;
	while not stop do
		if 2^i=n then
			stop:=true;
			finished:=true;
		elif  2^i > n then
			stop:=true;
			i:=i-1;
		else
			i:=i+1;
		fi;
	od;
l[1]:=i;
n:=n-2^i;
k:=2;
	while not finished do
		stop:=false;
		j:=1;
			while not stop do
				a:=2^(i-j);
					if a = n then
						stop:=true;
						finished:=true;
						l[k]:=i-j;
					elif a > n then
						stop:=false;
						j:=j+1;
					else
						stop:=true;
						l[k]:=i-j;
						i:=i-j;
						k:=k+1;
						n:=n-a;
					fi;
			od;
	od;
return l;
end;
################################################################################
################################################################################
################################################################################
sumo:=function(s,mid,i1,j1,k1,di1,l)

# Here, "s" is a list of generators for PGL(2,q), q odd.
# "i1,j1,k1" are involutions determining a basis triangle for the projective geometry.
# "mid" is the point corresponding to [1,1,1] in the triangle "i1,j1,k1".
# "di1" is the unity element on the "j1 v k1" axis.
# "l" is a list of natural numbers with which the 2-powers add up to a
# natural number "n".
# This function returns a value "n" on the axis "j1 v k1".

local M,0in,x,k,i,y,f,ll;

M:=Maximum(l);
	if 0 in l then
		0in:=true;
	else
		0in:=false;
	fi;
ll:=[];
x:=di1;
k:=1;
	for i in [1..M] do
			if i in l then
				x:=add(s,mid,i1,j1,k1,x,x);
					if x[1]=true then
						return x;
					else
						x:=x[2];
					fi;
				ll[k]:=x;
				k:=k+1;
			else
				x:=add(s,mid,i1,j1,k1,x,x);
					if x[1]=true then
						return x;
					else
						x:=x[2];
					fi;
			fi;
	od;
	if Length(ll)=0 then
		return di1;
	else
		y:=ll[1];
			for f in [2..(k-1)] do
				y:=add(s,mid,i1,j1,k1,y,ll[f]);
					if y[1]=true then
						return y;
					else
						y:=y[2];
					fi;
			od;
	fi;
	if 0in=true then
		return add(s,mid,i1,j1,k1,y,di1);
	else
		return [false,y];
	fi;
end;
################################################################################
################################################################################
################################################################################
multo:=function(s,mid,i1,j1,k1,di1,a,l)

# Here, "s" is a list of generators for PGL(2,q), q odd.
# "i1,j1,k1" are involutions determining a basis triangle for the projective geometry.
# "mid" is the point corresponding to [1,1,1] in the triangle "i1,j1,k1".
# "di1" is the unity element on the "j1 v k1" axis.
# "l" is a list of natural numbers with which the 2-powers add up to a
# natural number "n".
# "a" is an element in the black box field associated to the axis "j1 v k1".
# This function returns the value "a^n" on the axis "j1 v k1".

local M,0in,x,k,i,y,f,ll;

M:=Maximum(l);
	if 0 in l then
		0in:=true;
	else
		0in:=false;
	fi;
ll:=[];
x:=a;
k:=1;
	for i in [1..M] do
			if i in l then
				x:=mult(s,mid,i1,j1,k1,x,x);
					if x[1]=true then
						return x;
					else
						x:=x[2];
					fi;
				ll[k]:=x;
				k:=k+1;
			else
				x:=mult(s,mid,i1,j1,k1,x,x);
					if x[1]=true then
						return x;
					else
						x:=x[2];
					fi;
			fi;
	od;
	if Length(ll)=0 then
		return di1;
	else
		y:=ll[1];
			for f in [2..(k-1)] do
				y:=mult(s,mid,i1,j1,k1,y,ll[f]);
					if y[1]=true then
						return y;
					else
						y:=y[2];
					fi;
			od;
	fi;
	if 0in=true then
		return mult(s,mid,i1,j1,k1,y,a);
	else
		return [false,y];
	fi;
end;
################################################################################
################################################################################
################################################################################
toshn:=function(a,p)

# finds a square root of "a" in a field of prime size "p", "p" odd.
# This is an implementation of well-known Tonelli-Shanks algorithm.

local L,i,finished,e,s,found,n,x,b,g,r,m,finished2;

L:=p-1;
i:=0;
finished:=false;
	while not finished do
		if L mod 2 = 0 then
			L:=L/2;
			i:=i+1;
		else
			finished:=true;
		fi;
	od;
L:=p-1;
e:=i;
s:=L/(2^e);
found:=false;
n:=2;
	while not found do
		if Legendre(n,p)=-1 then
			found:=true;
		else
			found:=false;
			n:=n+1;
		fi;
	od;
x:=a^((s+1)/2) mod p;
b:=a^s mod p;
g:=n^s mod p;
r:=e;
finished:=false;
	while not finished do
		m:=0;
		finished2:=false;
			while not finished2 do
				if b^(2^m) mod p = 1 then
					finished2:=true;
				else
					m:=m+1;
				fi;
			od;

			if m=0 then
				return x;
			else
				x:=x*(g^(2^(r-m-1))) mod p;
				b:=b*(g^(2^(r-m)));
				g:=g^(2^(r-m));
				r:=m;
			fi;
	od;
end;
################################################################################
################################################################################
################################################################################
tosh:=function(s,mid,e1,e2,e3,di1,Ee,Eo,a,qnres)

# Here, "s" is a list of generators for PGL(2,q), "q" odd.
# "mid" is the point corresponding to [1,1,1] in the triangle "e1,e2,e3".
# "e1,e2,e3" are involutions determining a basis triangle for the projective geometry.
# "di1" is the unity element on the "e2 v e3" axis.
# Ee: even part, Eo: odd part of an exponent for "T".
# "a" is an element in the black box field - the axis "e2 v e3".
# "qnres" is a quadratic non-residue in the black box field - the axis "e2 v e3".
# This function returns either
# "false" in which case "a" may not be a square; or
# a square root of a black box field element "a".

local id,M,m,n2,n4,n5,x,b,g,r,finished,finished2,mm,bb,xx;

id:=di1;

x:=multo(s,mid,e1,e2,e3,di1,a,log2((Eo+1)/2));
	if x[1]=true then
		return x;
	else
		x:=x[2];
	fi;
b:=multo(s,mid,e1,e2,e3,di1,a,log2(Eo));
	if b[1]=true then
		return b;
	else
		b:=b[2];
	fi;
g:=multo(s,mid,e1,e2,e3,di1,qnres,log2(Eo));
	if g[1]=true then
		return g;
	else
		g:=g[2];
	fi;
r:=Ee;
finished:=false;
	while not finished do
		m:=0;
		finished2:=false;
			while not finished2 do
				if b=di1 and m=0 then
					finished2:=true;
				else
				    mm:=multo(s,mid,e1,e2,e3,di1,b,log2(2^m));;
				       if mm[1]=true then
				    	   return mm;
				       else
					       mm:=mm[2];
				       fi;
						if mm=id then
							finished2:=true;
						else
							m:=m+1;
						fi;
				fi;
			od;
			if m=0 then
				if mult(s,mid,e1,e2,e3,x,x)[2]=a then
					return x;
				else
					return false;
				fi;
			else
					if r-m-1 < 0 then
						return false;
					fi;
				xx:=multo(s,mid,e1,e2,e3,di1,g,log2(2^(r-m-1)));
					if xx[1]=true then
						return xx;
					else
						xx:=xx[2];
					fi;
				x:=mult(s,mid,e1,e2,e3,x,xx);
					if x[1]=true then
						return x;
					else
						x:=x[2];
					fi;
				bb:=multo(s,mid,e1,e2,e3,di1,g,log2(2^(r-m)));
					if bb[1]=true then
						return bb;
					else
						bb:=bb[2];
					fi;
				b:=mult(s,mid,e1,e2,e3,b,bb);
					if b[1]=true then
						return b;
					else
						b:=b[2];
					fi;
				g:=multo(s,mid,e1,e2,e3,di1,g,log2(2^(r-m)));
					if g[1]=true then
						return g;
					else
						g:=g[2];
					fi;
				r:=m;
			fi;
	od;
end;
################################################################################
################################################################################
################################################################################
qnres:=function(s,mid,i1,j1,k1,di1,res,l)

# Here, "s" is a list of generators for PGL(2,q), q odd.
# "i1,j1,k1" are involutions determining a basis triangle for the projective geometry.
# "mid" is the point corresponding to [1,1,1] in the triangle "i1,j1,k1".
# "di1" is the unity element on the "j1 v k1" axis.
# The element "res" is an element in the black box field on the axis "j1 V k1".
# This function is used when q=-1 mod4. Therefore -1 is a quadratic non-residue.
# Usually, "res=2".
# "l" is a list of natural numbers where the 2-powers add up to some natural number.
# This function returns a quadratic non-residue in the black box field - projective
# axis "j1 V k1".

local uv;

uv:=multo(s,mid,i1,j1,k1,di1,res,l);
	if uv[1]=true then
		return uv;
	else
		uv:=uv[2];
	fi;
	if uv=di1 then
		Print("-2 is a quadratic non-residue.\n");
		return res^j1;
	else
		Print("2 is a quadratic non-residue.\n");
		return res;
	fi;
end;
##############################
##############################
##############################
unip:=function(s,p)
# Here, "s" is a list of generators for PGL(2,p^k), "p" odd, "k" unknown.
# This function returns a list “l” where
# l[1] is a truth value whether it succeeds to produce unipotent element.
# l[2] and l[3] are two involutions whose product is a unipotent element.
# l[4] is a unipotent element which is the product of l[2] and l[3].


local x, found1,i1,ci1,found2,count,ti1,oi1,j1,cj1,tj1,oj1,k1,sc,m,di1,dj1,dk1,mid,n,L,Co,found,c,L1,L2,M1,M2,cc;

#####
#First, we find the coordinates of the unipotents.
#####
	if p mod 4 = 1 then
		Co:=toshn(-1,p);
			if Co > p-Co then
				Co:=p-Co;
			fi;
	else
		Co:=[];
		found:=false;
		c:=4;
			while not found do
				if Legendre(-1-c^2,p)=1 then
					cc:=toshn(-1-c^2,p);
						if cc > p-cc then
							cc:=p-cc;
						fi;
					Co:=[c,cc];
					found:=true;
				else
					c:=c+1;
				fi;
			od;
	fi;
####
#  Coordinates found!
Print("The coordinates of the unipotents are found.\n");
####
####
# Constructing a basis of the projective geometry
####
x:=Group(s);
found1:=false;
	while not found1 do
		i1:=invo(x);
		ci1:=Group(cent(i1,x));
		found2:=false;
		count:=1;
			while (not found2) and (count<=20) do
				ti1:=PseudoRandom(ci1);
				oi1:=Order(ti1);
					if oi1 mod 4 = 0 then
						found2:=true;
						found1:=true;
					else
						count:=count+1;
					fi;
			od;
	od;
found1:=false;
	while not found1 do
		j1:=invo(ci1);
			if j1<>i1 then
				cj1:=Group(cent(j1,x));
				found2:=false;
				count:=1;
					while (not found2) and (count <=20) do
						tj1:=PseudoRandom(cj1);
						oj1:=Order(tj1);
							if oj1 mod 4 = 0 then
								found2:=true;
								found1:=true;
							else
								count:=count+1;
							fi;
					od;
			else
				found1:=false;
			fi;
	od;
k1:=i1*j1;
####
# Involutions of right type have been found.
Print("Basis triangle for the projective plane is constructed..\n");
####
sc:=permij(s,i1,j1);;
sc:=sc^2;
ti1:=ti1^(oi1/4);
####
# Upto here, everything is characteristic free but now we have to separate \pm 1 mod 4.
####
	if p=3 then
		return unity(s,i1,j1,k1,ti1,sc);
	elif p mod 4 = 1 then
		m:=unity(s,i1,j1,k1,ti1,sc);
		di1:=m[1];
		dj1:=m[2];
		dk1:=m[3];
		mid:=inter(s,i1,di1,j1,dj1);
			if mid[1]=true then
				return mid;
			else
				mid:=mid[2];
			fi;
#		Print("The point (1,1,1) has been constructed.\n");
		L:=log2(Co);
#		Print("The binary representation of ",Co," involves the following powers of 2:");
#		Print(" ", L,".\n");
###
# The unipotent element will be the following:
###
		return sumo(s,mid,i1,j1,k1,di1,L);
	else
		m:=unity(s,i1,j1,k1,ti1,sc);
		di1:=m[1];
		dj1:=m[2];
		dk1:=m[3];
		mid:=inter(s,i1,di1,j1,dj1);
			if mid[1]=true then
				return mid;
			else
				mid:=mid[2];
			fi;
#		Print("The point (1,1,1) has been constructed.\n");
		L1:=log2(Co[1]);
		L2:=log2(Co[2]);
#		Print("A coordinate of a unipotent is (", Co[1],",",Co[2],",",1, ").\n");
		M1:=sumo(s,mid,i1,j1,k1,di1,L1);
			if M1[1]=true then
				return M1;
			else
				M1:=M1[2];
			fi;
#		Print("The point ", Co[1], " is constructed.\n");
		M2:=sumo(s,mid,k1,j1,i1,dk1,L2);
			if M2[1]=true then
				return M2;
			else
				M2:=M2[2];
			fi;
#		Print("The point ", Co[2], " is constructed.\n");
###
# The unipotent element will be the following:
###
		return inter(s,M1,i1,k1,M2);
	fi;
end;
################################################################################
################################################################################
################################################################################
##########                                                            ##########
########## THE REST OF THE CODE IS WRITTEN FOR UNKNOWN CHARACTERISTIC ##########
##########                                                            ##########
################################################################################
################################################################################
################################################################################
unibbf1:=function(s,E)
# Here, "s" is a list of generators of "G=PGL(2,q)"", "q" odd, "q=1 mod 4".
# "E" is an exponent for the group "G".
# This function returns either a list “l” where
# l[1] is a truth value whether it succeeds to produce unipotent element.
# l[2] and l[3] are two involutions whose product is a unipotent element.
# l[4] is a unipotent element which is the product of l[2] and l[3]; or
# returns "false" in which case algorithm fails to produce unipotent element.


local L,i,finished1,Ee,Eo,x,found1,i1,id,ci1,found2,count,ti1,j1,cj1,tj1,k1,sc,m,di1,dj1,dk1,mid,l,kk,finished2,t,uv;

###############
# Finding the odd and even part of the exponent "E".
###############
L:=E;
i:=0;
finished1:=false;
	while not finished1 do
		if L mod 2 = 0 then
			L:=L/2;
			i:=i+1;
		else
			finished1:=true;
		fi;
	od;
Ee:=i;
Eo:=E/(2^Ee);
##############
# Exponent is decomposed into odd and even part.
##############

####
# Constructing a basis of the projective geometry
####
x:=Group(s);
found1:=false;
	while not found1 do
		i1:=invo(x);
		id:=i1^2;;
		ci1:=Group(cent(i1,x));
		found2:=false;
		count:=1;
			while (not found2) and (count<=20) do
				ti1:=PseudoRandom(ci1);
					if is4div(ti1,id,Eo) then
						found2:=true;
						found1:=true;
					else
						count:=count+1;
					fi;
			od;
	od;
found1:=false;
	while not found1 do
		j1:=invo(ci1);
			if j1<>i1 then
				cj1:=Group(cent(j1,x));
				found2:=false;
				count:=1;
					while (not found2) and (count <=20) do
						tj1:=PseudoRandom(cj1);
							if is4div(tj1,id,Eo) then
								found2:=true;
								found1:=true;
							else
								count:=count+1;
							fi;
					od;
			else
				found1:=false;
			fi;
	od;
k1:=i1*j1;
####
Print("Basis triangle for the projective plane is constructed..\n");
####
sc:=permij(s,i1,j1);;
sc:=sc^2;
m:=unity(s,i1,j1,k1,ti1^(oi1/4),sc);
di1:=m[1];
dj1:=m[2];
dk1:=m[3];
mid:=inter(s,i1,di1,j1,dj1);
	if mid[1]=true then
		Print("The characteristic is 3.\n");
		return mid;
	else
		mid:=mid[2];
	fi;
#Print("Black box field is constructed.\n");
l:=log2(Eo);;
kk:=2;
finished1:=false;
finished2:=false;
	while not finished1 and kk<=7 do
		found1:=false;
			while not found1 do
				t:=PseudoRandom(ci1);
					if (t^2=id) and (t<>i1) and (t<>j1) and (t<>k1) then
						found1:=true;
					fi;
			od;
		Print("Checking whether a random black box field element has multiplicative order divisible by 4.\n");
		finished2:=false;
			while not finished2 do
				uv:=multo(s,mid,i1,j1,k1,di1,t,l);;
					if uv[1]=true then
						return uv;
					else
							uv:=uv[2];
					fi;
#				Print("Odd power is killed.\n");
					if uv=di1 then
						finished2:=true;
						kk:=kk+1;
						Print("Unfortunately, 4 does not divide the order of this black box field element.\n");
					else
						i:=1;
							while i<=Ee and (not finished2) do
#								Print("Started the loop to kill to 2-part.\n");
								uv:=mult(s,mid,i1,j1,k1,uv,uv);
									if uv[1]=true then
										return uv;
									else
											uv:=uv[2];
									fi;
									if uv=di1 then
										finished2:=true;
										kk:=kk+1;
										Print("Unfortunately, 4 does not divide the order of this black box field element.\n");
									else
										i:=i+1;
									fi;
							od;
					fi;
			od;
	od;
	if kk=8 then
		Print("Run the algorithm again, it failed to produce unipotent element.\n");
		return false;
	fi;
	end;
###############
###############
###############
unibbf2:=function(s,E)
# "s" is a list of generators of G=PGL(2,q), "q" odd, "q=-1 mod 4".
# "E" is an exponent for "G".
# This function returns a list “l” where
# l[1] is a truth value whether it succeeds to produce unipotent element.
# l[2] and l[3] are two involutions whose product is a unipotent element.
# l[4] is a unipotent element which is the product of l[2] and l[3].

local L,i,finished1,Ee,Eo,x,found1,i1,id,ci1,found2,count,ti1,j1,cj1,tj1,k1,sc,m,di1,dj1,dk1,mid,l,a2,res,qnres1,t1,t2,tt1,tt2,tt3,sqrttt3,x1,x2,candi;

###############
# Finding the odd and even part of the exponent "E".
###############
L:=E;
i:=0;
finished1:=false;
	while not finished1 do
		if L mod 2 = 0 then
			L:=L/2;
			i:=i+1;
		else
			finished1:=true;
		fi;
	od;
Ee:=i;
Eo:=E/(2^Ee);
##############
# Exponent is decomposed into odd and even part.
##############
####
# Constructing a basis of the projective geometry
####
x:=Group(s);
found1:=false;
	while not found1 do
		i1:=invo(x);
		id:=i1^2;
		ci1:=Group(cent(i1,x));
		found2:=false;
		count:=1;
			while (not found2) and (count<=20) do
				ti1:=PseudoRandom(ci1);
					if is4div(ti1,id,Eo) then
						found2:=true;
						found1:=true;
					else
						count:=count+1;
					fi;
			od;
	od;
found1:=false;
	while not found1 do
		j1:=invo(ci1);
			if j1<>i1 then
				cj1:=Group(cent(j1,x));
				found2:=false;
				count:=1;
					while (not found2) and (count <=20) do
						tj1:=PseudoRandom(cj1);
							if is4div(tj1,id,Eo) then
								found2:=true;
								found1:=true;
							else
								count:=count+1;
							fi;
					od;
			else
				found1:=false;
			fi;
	od;
k1:=i1*j1;
####
Print("Basis triangle for the projective plane is constructed.\n");
####
sc:=permij(s,i1,j1);;
sc:=sc^2;
m:=unity(s,i1,j1,k1,ti1^(oi1/4),sc);
di1:=m[1];
dj1:=m[2];
dk1:=m[3];
mid:=inter(s,i1,di1,j1,dj1);
	if mid[1]=true then
		Print("The characteristic is 3.\n");
		return mid;
	else
		mid:=mid[2];
	fi;
#Print("Black box field is constructed.\n");
l:=log2(Eo);;
a2:=add(s,mid,i1,j1,k1,di1,di1)[2];;
res:=a2;
#Print("Searching for a quadratic non-residue for Tonelli-Shanks algorithm.\n");
qnres1:=qnres(s,mid,i1,j1,k1,di1,res,l);
	if qnres1[1]=true then
		return qnres1;
	fi;
finished1:=false;
	while not finished1 do
		Print("We try random pairs (x,y) in K to locate unipotent.\n");
		found1:=false;
			while not found1 do
				t1:=PseudoRandom(ci1);
					if ((t1^2=id) and (t1<>i1) and (t1<>j1) and (t1<>k1)) then
						found1:=true;
					fi;
			od;
		found1:=false;
			while not found1 do
				t2:=PseudoRandom(ci1);
					if (t2<>t1) and (t2^2=id) and (t2<>i1) and (t2<>j1) and (t2<>k1) then
							found1:=true;
					fi;
			od;
		tt1:=mult(s,mid,i1,j1,k1,t1,t1);
			if tt1[1]=true then
				return tt1;
			fi;
		tt2:=mult(s,mid,i1,j1,k1,t2,t2);
			if tt2[1]=true then
				return tt2;
			fi;
		tt3:=add(s,mid,i1,j1,k1,tt1[2]^j1,tt2[2]^j1);
			if tt3[1]=true then
				return tt3;
			fi;
		Print("Checking whether -x^2-y^2 is a square root.\n");
		sqrttt3:=tosh(s,mid,i1,j1,k1,di1,Ee,Eo,tt3[2],qnres1);
			if sqrttt3=false then
				Print("Unfortunately, -x^2-y^2 is a quadratic non-residue.\n");
			elif sqrttt3[1]=true then
				return sqrttt3;
			else
				finished1:=true;
				Print("-x^2-y^2 is a quadratic residue and we found its square root.\n");
				x1:=mult(s,mid,i1,j1,k1,t1,sqrttt3^di1);
					if x1[1]=true then
						return x1;
					fi;
				x1:=x1[2];
				x2:=mult(s,mid,i1,j1,k1,t2,sqrttt3^di1);
					if x2[1]=true then
						return x2;
					fi;
				x2:=x2[2]^dj1;
				candi:=inter(s,i1,x1,k1,x2);
					if candi[1]=true then
						Print("Enforced serendipity is accomplished!\n");
						return candi;
					else
						Print("Run the algorithm again, it failed to produce unipotent element.\n");
					fi;
			fi;
	od;
end;
###############
###############
###############
unipoly:=function(s,E)
# This function is a combination of the functions "unibbf1" and "unibbf2" above.
# It first runs unibbf1 and if it succeeds to construct a unipotent element, then
# we are done. If it fails to construct an element of order 4 in the black box
# field

local L,i,finished1,Ee,Eo,x,i1,id,ci1,found,found1,count,ti1,j1,cj1,tj1,k1,sc,m,di1,dj1,mid,a2,l,kk,finished2,qnres1,t,uv,kkk,t1,t2,tt1,tt2,tt3,sqrttt3,x1,x2,candi;
###############
# Finding the odd and even part of the exponent "E".
###############
L:=E;
i:=0;
finished1:=false;
	while not finished1 do
		if L mod 2 = 0 then
			L:=L/2;
			i:=i+1;
		else
			finished1:=true;
		fi;
	od;
Ee:=i;
Eo:=E/(2^Ee);
##############
# Exponent is decomposed into odd and even part.
##############
##############
# Constructing a basis of the projective geometry
##############
x:=Group(s);
finished1:=false;
	while not finished1 do
		i1:=invo(x);
		id:=i1^2;
		ci1:=Group(cent(i1,x));
		found:=false;
		count:=1;
			while (not found) and (count<=20) do
				ti1:=PseudoRandom(ci1);
					if is4div(ti1,id,Eo) then
						found:=true;
						finished1:=true;
					else
						count:=count+1;
					fi;
			od;
	od;
finished1:=false;
	while not finished1 do
		j1:=invo(ci1);
			if j1<>i1 then
				cj1:=Group(cent(j1,x));
				found:=false;
				count:=1;
					while (not found) and (count <=20) do
						tj1:=PseudoRandom(cj1);
							if is4div(tj1,id,Eo) then
								found:=true;
								finished1:=true;
							else
								count:=count+1;
							fi;
					od;
			else
				finished1:=false;
			fi;
	od;
k1:=i1*j1;
####################
Print("Basis triangle for the projective plane is constructed.\n");
####################
sc:=permij(s,i1,j1);;
sc:=sc^2;
ti1:=ti1^(oi1/4);
m:=unity(s,i1,j1,k1,ti1,sc);
di1:=m[1];
dj1:=m[2];
####################
#Print("Unity elements on the axes are constructed.\n");
####################
mid:=inter(s,i1,di1,j1,dj1);
	if mid[1]=true then
		Print("The characteristic is 3.\n");
		return mid;
	else
		mid:=mid[2];
	fi;
#Print("Black box field is constructed.\n");
a2:=add(s,mid,i1,j1,k1,di1,di1);
	if a2[1]=true then
		Print("The characteristic is ", 5, ".\n");
		return a2;
	else
		a2:=a2[2];
	fi;
##############
Print("We first treat the field as if it is of type q=1 mod 4.\n");
##############
l:=log2(Eo);;
kk:=1;
finished1:=false;
finished2:=false;
	while not finished1 and kk<=7 do
		found1:=false;
			while not found1 do
				t:=PseudoRandom(ci1);
					if (t^2=id) and (t<>i1) and (t<>j1) and (t<>k1) then
						found1:=true;
					fi;
			od;
		Print("Checking whether a random black box field element has multiplicative order divisible by 4.\n");
		finished2:=false;
			while not finished2 do
				uv:=multo(s,mid,i1,j1,k1,di1,t,l);;
					if uv[1]=true then
						return uv;
					else
							uv:=uv[2];
					fi;
					if uv=di1 then
						finished2:=true;
						kk:=kk+1;
						Print("Unfortunately, 4 does not divide the order of this black box field element.\n");
					else
						i:=1;
							while i<=Ee and (not finished2) do
								uv:=mult(s,mid,i1,j1,k1,uv,uv);
									if uv[1]=true then
										return uv;
									else
											uv:=uv[2];
									fi;
									if uv=di1 then
										finished2:=true;
										kk:=kk+1;
										Print("We can not produce element of order 4 from this black box field element.\n");
									else
										i:=i+1;
									fi;
							od;
					fi;
			od;
	od;
	if not finished1 then
		Print("It looks like the black box field is of type q=-1 mod4.\n");
		Print("Searching for a quadratic non-residue for Tonelli-Shanks algorithm.\n");
		qnres1:=qnres(s,mid,i1,j1,k1,di1,a2,l);
			if qnres1[1]=true then
				return qnres1;
			fi;
			kkk:=1;
			while not finished1 and kkk<=7 do
				Print("We try random pairs (x,y) in K to locate unipotent.\n");
				found1:=false;
					while not found1 do
						t1:=PseudoRandom(ci1);
							if ((t1^2=id) and (t1<>i1) and (t1<>j1) and (t1<>k1)) then
								found1:=true;
								fi;
					od;
				found1:=false;
					while not found1 do
						t2:=PseudoRandom(ci1);
							if (t2<>t1) and (t2^2=id) and (t2<>i1) and (t2<>j1) and (t2<>k1) then
								found1:=true;
							fi;
					od;
				tt1:=mult(s,mid,i1,j1,k1,t1,t1);
					if tt1[1]=true then
						return tt1;
					fi;
				tt2:=mult(s,mid,i1,j1,k1,t2,t2);
					if tt2[1]=true then
						return tt2;
					fi;
				tt3:=add(s,mid,i1,j1,k1,tt1[2]^j1,tt2[2]^j1);
					if tt3[1]=true then
						return tt3;
					fi;
				sqrttt3:=tosh(s,mid,i1,j1,k1,di1,Ee,Eo,tt3[2],qnres1);
					if sqrttt3=false then
						Print("Unfortunately, -x^2-y^2 is a quadratic non-residue.\n");
						kkk:=kkk+1;
					elif sqrttt3[1]=true then
						return sqrttt3;
					else
						Print("-x^2-y^2 is a quadratic residue and we found its square root.\n");
						x1:=mult(s,mid,i1,j1,k1,t1,sqrttt3^di1);
							if x1[1]=true then
								return x1;
							fi;
						x1:=x1[2];
						x2:=mult(s,mid,i1,j1,k1,t2,sqrttt3^di1);
							if x2[1]=true then
								return x2;
							fi;
						x2:=x2[2]^dj1;
						candi:=inter(s,i1,x1,k1,x2);
							if candi[1]=true then
								Print("Enforced serendipity is accomplished!\n");
								return candi;
							else
								kkk:=kkk+1;
							fi;
					fi;
			od;
		fi;
		if kk=8 and kkk=8 and not finished1 then
			Print("Run the algorithm again, it failed to produce unipotent element.\n");
		fi;
	end;
